import { NextRequest, NextResponse } from 'next/server';

// Cache em mem√≥ria otimizado para os dados da CoinMarketCap
let cachedData: any = null;
let lastFetchTime: number = 0;
const CACHE_DURATION = 15 * 60 * 1000; // 15 minutos em millisegundos (aumentado)

// Cache de fallback para dados est√°ticos
const FALLBACK_DATA = [
  {
    symbol: 'BTC',
    name: 'Bitcoin',
    price: 45000,
    change_24h: 2.5,
    change_7d: 5.2,
    market_cap: 850000000000,
    volume_24h: 25000000000,
    circulating_supply: 19500000,
    total_supply: 21000000,
    max_supply: 21000000,
    cmc_rank: 1,
    last_updated: new Date().toISOString(),
    category: 'Cryptocurrency'
  },
  {
    symbol: 'ETH',
    name: 'Ethereum',
    price: 2800,
    change_24h: 1.8,
    change_7d: 3.1,
    market_cap: 350000000000,
    volume_24h: 15000000000,
    circulating_supply: 120000000,
    total_supply: 120000000,
    max_supply: null,
    cmc_rank: 2,
    last_updated: new Date().toISOString(),
    category: 'Cryptocurrency'
  }
];

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  const limit = searchParams.get('limit') || '15';

  if (action === 'latest') {
    const now = Date.now();
    
    // Verificar se temos dados em cache e se ainda s√£o v√°lidos
    if (cachedData && (now - lastFetchTime) < CACHE_DURATION) {
      console.log('üì¶ Retornando dados do cache (CoinMarketCap)');
      return NextResponse.json({
        success: true,
        data: cachedData.slice(0, parseInt(limit)),
        cached: true,
        cacheAge: Math.floor((now - lastFetchTime) / 1000)
      });
    }

    // Se n√£o temos cache v√°lido, buscar da API com timeout
    try {
      console.log('üîÑ Buscando dados da API CoinMarketCap...');
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 segundos timeout
      
      const response = await fetch(
        `https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?limit=${limit}&convert=USD`,
        {
          headers: {
            'X-CMC_PRO_API_KEY': 'c9398711-1ea4-4f2c-81a9-01eb8d1617a7',
            'Accept': 'application/json'
          },
          signal: controller.signal
        }
      );

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`CoinMarketCap API error: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.data) {
        // Processar e armazenar no cache
        const processedData = result.data.map((crypto: any) => ({
          symbol: crypto.symbol,
          name: crypto.name,
          price: crypto.quote.USD.price,
          change_24h: crypto.quote.USD.percent_change_24h,
          change_7d: crypto.quote.USD.percent_change_7d,
          market_cap: crypto.quote.USD.market_cap,
          volume_24h: crypto.quote.USD.volume_24h,
          circulating_supply: crypto.circulating_supply,
          total_supply: crypto.total_supply,
          max_supply: crypto.max_supply,
          cmc_rank: crypto.cmc_rank,
          last_updated: crypto.last_updated,
          category: crypto.category
        }));

        // Atualizar cache
        cachedData = processedData;
        lastFetchTime = now;

        console.log('‚úÖ Dados da CoinMarketCap atualizados e armazenados no cache');
        
        return NextResponse.json({
          success: true,
          data: processedData,
          cached: false,
          cacheAge: 0
        });
      } else {
        throw new Error('Invalid response format from CoinMarketCap');
      }
    } catch (error: any) {
      console.error('‚ùå Erro ao buscar dados da CoinMarketCap:', error.message);
      
      // Se temos dados em cache (mesmo expirados), retornar como fallback
      if (cachedData) {
        console.log('üîÑ Retornando dados expirados como fallback');
        return NextResponse.json({
          success: true,
          data: cachedData.slice(0, parseInt(limit)),
          cached: true,
          cacheAge: Math.floor((now - lastFetchTime) / 1000),
          warning: 'Dados podem estar desatualizados devido a erro na API'
        });
      }
      
      // Fallback para dados est√°ticos
      console.log('üîÑ Retornando dados est√°ticos como fallback');
      return NextResponse.json({
        success: true,
        data: FALLBACK_DATA.slice(0, parseInt(limit)),
        cached: true,
        cacheAge: 0,
        warning: 'Usando dados est√°ticos devido a erro na API'
      });
    }
  }

  return NextResponse.json({
    success: false,
    error: 'Invalid action parameter'
  }, { status: 400 });
}
