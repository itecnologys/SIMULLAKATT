import { NextRequest, NextResponse } from 'next/server';

// Cache em mem√≥ria para os dados da CoinMarketCap
let cachedData: any = null;
let lastFetchTime: number = 0;
const CACHE_DURATION = 6 * 60 * 1000; // 6 minutos em millisegundos

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const action = searchParams.get('action');
  const limit = searchParams.get('limit') || '15';

  if (action === 'latest') {
    const now = Date.now();
    
    // Verificar se temos dados em cache e se ainda s√£o v√°lidos
    if (cachedData && (now - lastFetchTime) < CACHE_DURATION) {
      console.log('üì¶ Retornando dados do cache (CoinMarketCap)');
      return NextResponse.json({
        success: true,
        data: cachedData.slice(0, parseInt(limit)),
        cached: true,
        cacheAge: Math.floor((now - lastFetchTime) / 1000) // idade em segundos
      });
    }

    // Se n√£o temos cache v√°lido, buscar da API
    try {
      console.log('üîÑ Buscando dados da API CoinMarketCap...');
      
      const response = await fetch(
        `https://pro-api.coinmarketcap.com/v1/cryptocurrency/listings/latest?limit=${limit}&convert=USD`,
        {
          headers: {
            'X-CMC_PRO_API_KEY': 'c9398711-1ea4-4f2c-81a9-01eb8d1617a7',
            'Accept': 'application/json'
          }
        }
      );

      if (!response.ok) {
        throw new Error(`CoinMarketCap API error: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.data) {
        // Processar e armazenar no cache
        const processedData = result.data.map((crypto: any) => ({
          symbol: crypto.symbol,
          name: crypto.name,
          price: crypto.quote.USD.price,
          change_24h: crypto.quote.USD.percent_change_24h,
          change_7d: crypto.quote.USD.percent_change_7d,
          market_cap: crypto.quote.USD.market_cap,
          volume_24h: crypto.quote.USD.volume_24h,
          circulating_supply: crypto.circulating_supply,
          total_supply: crypto.total_supply,
          max_supply: crypto.max_supply,
          cmc_rank: crypto.cmc_rank,
          last_updated: crypto.last_updated,
          category: crypto.category
        }));

        // Atualizar cache
        cachedData = processedData;
        lastFetchTime = now;

        console.log('‚úÖ Dados da CoinMarketCap atualizados e armazenados no cache');
        
        return NextResponse.json({
          success: true,
          data: processedData,
          cached: false,
          cacheAge: 0
        });
      } else {
        throw new Error('Invalid response format from CoinMarketCap');
      }
    } catch (error: any) {
      console.error('‚ùå Erro ao buscar dados da CoinMarketCap:', error.message);
      
      // Se temos dados em cache (mesmo expirados), retornar como fallback
      if (cachedData) {
        console.log('üîÑ Retornando dados expirados como fallback');
        return NextResponse.json({
          success: true,
          data: cachedData.slice(0, parseInt(limit)),
          cached: true,
          cacheAge: Math.floor((now - lastFetchTime) / 1000),
          warning: 'Dados podem estar desatualizados devido a erro na API'
        });
      }
      
      return NextResponse.json({
        success: false,
        error: error.message
      }, { status: 500 });
    }
  }

  return NextResponse.json({
    success: false,
    error: 'Invalid action parameter'
  }, { status: 400 });
}
